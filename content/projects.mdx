---
title: "about"
published: true
---

----

# @work

## The Collective

## Ampify Studio

## ROLI Dashboard

## DREAM DSP Designer

DREAM makes DSP chips for audio applications.
With that, they also make and sell reference designs
for complex projects. To accelerate development
they have ready-made DSP algorithms and wanted
a way to visually build instruments and generate
the code for them, ready to be flashed on device.

DSP Designer does just that, and more.
I worked on various parts of the software, including
the topological graph sorting of the DSP nodes
and architecture redesign.

## Cathodique 2.0

While studying at [ISEN Lille](), myself and the other Music Tech
students worked on an interactive video mapping experience.

The mapping was projected on the facade of the [University Catholique]()
of Lille, France.

The show started with 10 minutes of video mapping then 20 minutes
where the public could play collaborative games on the facade via
four [Leap Motions]() installed on pedestals. The show looped
all night, loads of people got to play on this massive projector!

Each game mapped onto the facade. For example, we had a collaborative
sequencer where each window was a step and each player controlled a
different sound. The players could press a window to activate a
sound when the sequencer reached a given window.

It was part of...

[Full video of the mapping](https://www.youtube.com/watch?v=HnqodTDU2QI)
[YouTube: spectators view!](https://www.youtube.com/watch?v=WFbpJhSFP90)

----

# @home

## aud

<p align="center">
<img src="/images/aud.gif"></img>
</p>

[aud](https://github.com/nicochatzi/aud) is a CLI tool to help with audio-related tasks.

It started from just needing to very quickly watch
MIDI input stream. From there I needed some filtering
and saving of the messages. So I embedded a Lua runtime
with script hot-reloading and runtime reload (if the script
is borked). Now it's a "scriptable audio CLI tool"
that can hook into audio/midi streams and do loads of things
through hot-Lua script, e.g. send/receive data, save-to-disk, etc...

The tool can also be used as a library in C. From there,
an application can stream audio as a source to a destination
(an <code>aud</code> client). The client can then run a terminal-based
oscilloscope and hook into the stream with a Lua script.
Currently, it blasts audio over UDP with minimal package
validation.

## rume

## NixOS

Recently, I've taken the (so far shallow) dive into NixOS.
The idea of a declarative, reproducible and generational Linux
OS is amazing. On top of that, the nix shells/envs are
a godsend for development without having to spin-up
docker containers for every project or install dependencies
globally.

You can find my NixOS configuration [somewhere](https://github.com/nicochatzi/dotfiles/tree/main/.nixfiles)
[in my dotfiles](https://github.com/nicochatzi/dotfiles).
For the moment I still use other OSes that use the same dotfiles
so I have not yet fully committed to the all-in home-manager setup.

I have a few machines setup now with more or less the same config, including
a base-model M1 Macbook Air. The setup idles at around 400MB RAM so
the Air with it's 8GB RAM and 128GB actually works beautifully.
Especially compared to macOS/windows which idle at around 6GB.

That being said, I've found the non-FHS compliance to be the main hurdle
to using it a my daily dev driver. Particularly for compiled programs
which use dynamic linker/loader, be ready to <code>patchelf</code>...


