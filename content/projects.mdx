---
title: "projects"
---

----

# @work

Some projects I've worked on that are in the public domain.

## The Collective @ Focusrite

<p align="center">
<video autoplay playsinline loop muted width="1000">
    <source src="/images/collective.mp4" type="video/mp4"/>
</video>
</p>

[The Collective](https://collective.focusrite.com/) is a brand of
[Focusrite Group](https://focusrite.com/). It's a VST plugin
brand and platform. We designed the plugins with [Sonible](https://www.sonible.com/),
who built the plugins.

As part of this project, I contributed to the backend and frontend
of the platform. My primary contribution was driving the developement
of a Rust-based library that served as a DRM for the plugin
and the access point for the third-party software (Sonible plugins)
to access our backend.

Rust was chosen for a number of reasons:

1. __Security__: a DRM library is bad actors' main target.
2. __Strong C interoperability__.
3. It has a __solid networking stack__ in the standard library.
4. It has __fantastic threading__ primitives and compile-time checks.
5. It was a chance to __introduce Rust into the company__ with a small,
self-contained project.

The plugins were shipped with the Rust library in 2022 and are still on the market.

Rust in prod achieved! ðŸŽ‰

## Ampify Studio @ Ampify

<p align="center">
<img src="/images/ampify-studio.png"></img>
</p>

## ROLI Dashboard @ ROLI

<p align="center">
<img src="/images/roli-dashboard.gif"></img>
</p>

## DSP Designer @ DREAM

<p align="center">
<img src="/images/profile.jpg"></img>
</p>


DREAM makes DSP chips for audio applications.
With that, they also make and sell reference designs
for complex projects. To accelerate development
they have ready-made DSP algorithms and wanted
a way to visually build instruments and generate
the code for them, ready to be flashed on device.

DSP Designer does just that, and more.
I worked on various parts of the software, including
the topological graph sorting of the DSP nodes
and architecture redesign.

## Cathodique 2.0 @ ISEN

While studying at [ISEN Lille](), myself and the other Music Tech
students worked on an interactive video mapping experience.

The mapping was projected on the facade of the [University Catholique]()
of Lille, France.

The show started with 10 minutes of video mapping then 20 minutes
where the public could play collaborative games on the facade via
four [Leap Motions]() installed on pedestals. The show looped
all night, loads of people got to play on this massive projector!

Each game mapped onto the facade. For example, we had a collaborative
sequencer where each window was a step and each player controlled a
different sound. The players could press a window to activate a
sound when the sequencer reached a given window.

It was part of...

[Full video of the mapping](https://www.youtube.com/watch?v=HnqodTDU2QI)
[YouTube: spectators view!](https://www.youtube.com/watch?v=WFbpJhSFP90)

----

# @home

At home, I mainly look for side quests to do in Rust and a little bit of Zig nowadays.

## aud

<p align="center">
<img src="/images/aud.gif"></img>
</p>

[aud](https://github.com/nicochatzi/aud) is a CLI tool to help with audio-related tasks.

It started from just needing to very quickly watch
MIDI input stream. From there I needed some filtering
and saving of the messages. So I embedded a Lua runtime
with script hot-reloading and runtime reload (if the script
is borked). Now it's a "scriptable audio CLI tool"
that can hook into audio/midi streams and do loads of things
through hot-Lua script, e.g. send/receive data, save-to-disk, etc...

The tool can also be used as a library in C. From there,
an application can stream audio as a source to a destination
(an <code>aud</code> client). The client can then run a terminal-based
oscilloscope and hook into the stream with a Lua script.
Currently, it blasts audio over UDP with minimal package
validation.

## rume

[rume](https://github.com/nicochatzi/rume) is a library
for building DSP graphs for virtual instruments in Rust.
It comes with some DSP building blocks and some gnarly
hand-rolled graph representation and sorting code in Rust, fun :)

At [Focusrite/Novation](), we used it during a hackday to build
a synth with [tauri]() has a frontend and rume as the audio engine
back in late 2020. Since then, it hasn't gotten much love...
In hindsight, I think there are better approaches to solving this
type of problem. Going all in on Rust macros can be painful for the
library developer and consumer.

The idea from [SOUL/CMajor](), it's an experimental rip-off
using Rust macros. Realistically, it's more of a Rust exercise.
CMajor is far better suited for what this type of graph syntax
tries to achieve. Check the language out if you haven't yet!


## NixOS

Recently, I've taken the (so far shallow) dive into NixOS.
The idea of a declarative, reproducible and generational Linux
OS is amazing. On top of that, the nix shells/envs are
a godsend for development without having to spin-up
docker containers for every project or install dependencies
globally.

You can find my NixOS configuration [somewhere](https://github.com/nicochatzi/dotfiles/tree/main/.nixfiles)
[in my dotfiles](https://github.com/nicochatzi/dotfiles).
For the moment I still use other OSes that use the same dotfiles
so I have not yet fully committed to the all-in home-manager setup.

I have a few machines setup now with more or less the same config, including
a base-model M1 Macbook Air. The setup idles at around 400MB RAM so
the Air with it's 8GB RAM and 128GB actually works beautifully.
Especially compared to macOS/windows which idle at around 6GB.

That being said, I've found the non-FHS compliance to be the main hurdle
to using it a my daily dev driver. Particularly for compiled programs
which use dynamic linker/loader, be ready to <code>patchelf</code>...


